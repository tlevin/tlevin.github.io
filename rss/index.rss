<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Todd Levin</title><description>Things that intrigue me</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Sun, 04 Oct 2015 18:02:40 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>The Night Before Hack Reactor</title><description>&lt;p&gt;It is hard to express the emotions one goes through on the verge of a monumental endeavor such as Hack Reactor.   Hack Reactor is a immersive coding coding bootcamp in San Francisco that takes you from a base knowledge of coding and transforms you into an employable software engineer.   Taking&lt;/p&gt;</description><link>http://localhost:2368/the-night-before-hack-reactor/</link><guid isPermaLink="false">4e400d58-1964-4939-8742-865ad671d586</guid><category>Hack Reactor</category><dc:creator>Todd Levin</dc:creator><pubDate>Sun, 04 Oct 2015 18:00:24 GMT</pubDate><content:encoded>&lt;p&gt;It is hard to express the emotions one goes through on the verge of a monumental endeavor such as Hack Reactor.   Hack Reactor is a immersive coding coding bootcamp in San Francisco that takes you from a base knowledge of coding and transforms you into an employable software engineer.   Taking a 4 year computer science degree and condensing it to 3 months.&lt;/p&gt;

&lt;p&gt;I believe that is how diamonds are made from carbon.   A whole lot of pressure. &lt;/p&gt;

&lt;h3 id="agiledevelopment"&gt;Agile development&lt;/h3&gt;

&lt;p&gt;I didn't know about the concept of &lt;a href="https://en.wikipedia.org/wiki/Agile_software_development"&gt;agile development&lt;/a&gt; until I started looking into the Hack Reactor program.  It is a set of software development methods that focus on constant iteration on design and plan, continuous improvement and rapid response to change.&lt;/p&gt;

&lt;p&gt;The folks at Hack Reactor run the bootcamp curriculum based on this concept.  Different topics are divided into two day sprints that requires the students to deep dive into a subject, and then immediately change to something new.  That keeps people constantly learning and reacting to a fast pace environment.  The other benefit of agile development at Hack Reactor is the curriculum is never stale, it adheres to an evolutionary development mindset where change is based on weekly feedback.&lt;/p&gt;

&lt;h3 id="threemonthsremoved"&gt;Three months removed&lt;/h3&gt;

&lt;p&gt;The day at Hack Reactor runs from 9am to 8pm Monday through Saturday. If you are just doing the scheduled day a 66 hour work week would make most people pause.  Consider then that a good number of people will stay around 1-2 hours after each day for study or to catch up on the work of the current sprint.  I have never experienced a 80 hour work week, but I will have to prepare myself for it.  Family and friends, I'll see you in January.&lt;/p&gt;

&lt;h3 id="socialnetworking"&gt;Social networking&lt;/h3&gt;

&lt;p&gt;The technical skills of a software engineer are only one aspect of what Hack Reactor teaches.  The common intensive program that you and your cohort experiences builds an instant bond.  Social nights every Saturday night allows for the releasing of the stress and tension of the week as well as building on personal connections. The focus on cooperative collaboration is stressed through pair programming and group projects since in the industry, you are rarely working solo on a project.  &lt;/p&gt;

&lt;p&gt;After graduation you are part of an alumni network that rivals some universities in how focused it is in one industry.  The chance of running into a Hack Reactor graduate grows with every cohort that graduates.  Having an instant professional network of software engineers upon graduation is a benefit that I can't even fathom at this point.&lt;/p&gt;

&lt;h3 id="onefootinfrontoftheother"&gt;One foot in front of the other&lt;/h3&gt;

&lt;p&gt;Rather than look at the sheer enormity of material I will ingest over the next three months, I must look at it one day at a time, one sprint at a time and just keep going.&lt;/p&gt;

&lt;p&gt;The Chinese philosopher Lao-tzu put it best: &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A journey of a thousand miles begins with a single step. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here's to the first step.&lt;/p&gt;</content:encoded></item><item><title>Data structures: stack in practice</title><description>&lt;p&gt;I have been looking into different data structures as I prepare for Hack Reactor and the one I would like to talk about here is a stack.  I ran across this problem on &lt;a href="http://www.coderbyte.com/CodingArea/Editor.php?ct=Bracket%20Matcher&amp;amp;lan=JavaScript"&gt;Coderbyte&lt;/a&gt; and it seems like a perfect candidate for application of this concept.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Using the JavaScript language,&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;</description><link>http://localhost:2368/data-structures-stack/</link><guid isPermaLink="false">e208b9b9-00df-4dee-827c-559e9d7ac1d3</guid><category>JavaScript</category><dc:creator>Todd Levin</dc:creator><pubDate>Fri, 02 Oct 2015 02:20:00 GMT</pubDate><content:encoded>&lt;p&gt;I have been looking into different data structures as I prepare for Hack Reactor and the one I would like to talk about here is a stack.  I ran across this problem on &lt;a href="http://www.coderbyte.com/CodingArea/Editor.php?ct=Bracket%20Matcher&amp;amp;lan=JavaScript"&gt;Coderbyte&lt;/a&gt; and it seems like a perfect candidate for application of this concept.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Using the JavaScript language, have the function BracketMatcher(str) take the str parameter being passed and return 1 if the brackets are correctly matched and each one is accounted for. Otherwise return 0. For example: if str is "(hello (world))", then the output should be 1, but if str is "((hello (world))" the the output should be 0 because the brackets do not correctly match up. Only "(" and ")" will be used as brackets. If str contains no brackets return 1.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id="whatisastack"&gt;What is a stack?&lt;/h4&gt;

&lt;p&gt;Think of a stack as a can of Pringles, you can add chips and remove chips from only one side. A stack is a basic linear data structure where the last value added in is the first value out.  It often is implemented as an array or a linked list since a stack only needs very basic methods to control access such as &lt;code&gt;pop()&lt;/code&gt; to remove a value and &lt;code&gt;push()&lt;/code&gt; to add a value.  The best way to examine it further is to see it in action.&lt;/p&gt;

&lt;h4 id="bracketmatcher"&gt;BracketMatcher&lt;/h4&gt;

&lt;p&gt;Let's examine what the problem asks for and why a stack is the appropriate data structure for the job.  The issue with balancing brackets is in order to properly implement, we need to keep track of them as they go since an open bracket &lt;code&gt;(&lt;/code&gt; is not always going to be followed by it's pair in the case of nested brackets as seen in the example &lt;code&gt;(hello (world))&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is where a stack is good.  Each &lt;code&gt;(&lt;/code&gt; it comes across will be added to the top and is removed only when a &lt;code&gt;)&lt;/code&gt; is encountered.  A balanced string will have an empty stack at the end of it.  Let's see my solution to the problem.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function BracketMatcher(str){
  var stack = [];
  for(var i = 0; i &amp;lt; str.length; i++){
    if(str[i] === '('){
      stack.push(str[i]);
   } else if ( str[i] === ')'){
     if(stack[stack.length-1] === '('){
       stack.pop();
     } else {
       return 0;
     }
   }
 }
 if( stack.length === 0 ){
   return 1;
 }
 return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We initialize a stack in the form of an array and iterate across the string.  As it goes it will add and remove &lt;code&gt;(&lt;/code&gt;'s from the stack.  If all goes well we will have a balanced string indicated by an empty stack after the iteration.  If so, we have our return value of 1.&lt;/p&gt;</content:encoded></item><item><title>Four stages of competence in programming</title><description>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/10/Thoughts.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;I started learning how to code in JavaScript in early 2015 and I had no direction, instruction, or plan.  In fact I didn't even know that I wanted to learn JavaScript, I just heard of this "coding" thing on the internet.&lt;/p&gt;

&lt;p&gt;This is &lt;strong&gt;not&lt;/strong&gt; how to learn something technical.&lt;/p&gt;

&lt;h4 id="unconsciouscompetence"&gt;Unconscious&lt;/h4&gt;</description><link>http://localhost:2368/four-stages-competence/</link><guid isPermaLink="false">0f99467a-b7bb-4dfd-a644-f489bad74538</guid><category>Learn To Code</category><category>JavaScript</category><dc:creator>Todd Levin</dc:creator><pubDate>Thu, 01 Oct 2015 19:30:58 GMT</pubDate><media:content url="http://localhost:2368/content/images/2015/10/Thoughts-1.jpg" medium="image"/><content:encoded>&lt;img src="http://localhost:2368/content/images/2015/10/Thoughts-1.jpg" alt="Four stages of competence in programming"&gt;&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/10/Thoughts.jpg" alt="Four stages of competence in programming"&gt;&lt;/p&gt;

&lt;p&gt;I started learning how to code in JavaScript in early 2015 and I had no direction, instruction, or plan.  In fact I didn't even know that I wanted to learn JavaScript, I just heard of this "coding" thing on the internet.&lt;/p&gt;

&lt;p&gt;This is &lt;strong&gt;not&lt;/strong&gt; how to learn something technical.&lt;/p&gt;

&lt;h4 id="unconsciouscompetence"&gt;Unconscious Competence&lt;/h4&gt;

&lt;p&gt;If you look at the &lt;a href="https://en.wikipedia.org/wiki/Four_stages_of_competence"&gt;four stages of competence&lt;/a&gt; model, you will start with unconscious incompetence.  You don't know a skill and don't recognize that the skill is valuable.  You can be oblivious to the entire tech industry and what a programmer actually &lt;em&gt;does.&lt;/em&gt; I spent much of my life like this.  Ignorance is bliss.&lt;/p&gt;

&lt;h4 id="consciousincompetence"&gt;Conscious Incompetence&lt;/h4&gt;

&lt;p&gt;Once you gain the understanding that you don't know a skill and you think it &lt;strong&gt;is&lt;/strong&gt; very valuable to learn, you start the process of learning.  You have now entered one of the most frustrating stages, conscious incompetence.  You want to learn, you just don't have the skills.  You stumble and make mistakes, but this is the basis of learning.&lt;/p&gt;

&lt;p&gt;Here is where most people form their base knowledge of a skill.  You could scour the online resources such as &lt;a href="http://www.codeschool.com"&gt;codeschool&lt;/a&gt;, &lt;a href="http://www.codecademy.com"&gt;codecademy&lt;/a&gt;, &lt;a href="http://www.teamtreehouse.com"&gt;treehouse&lt;/a&gt;, etc. Finding out what you &lt;strong&gt;don't&lt;/strong&gt; know is important to building a plan.  Get involved in discussions on &lt;a href="http://www.quora.com"&gt;Quora&lt;/a&gt; or &lt;a href="http://stackoverflow.com/"&gt;Stack Overflow&lt;/a&gt; to build on your knowledge.&lt;/p&gt;

&lt;h4 id="consciouscompetence"&gt;Conscious Competence&lt;/h4&gt;

&lt;p&gt;Conscious competence is the stage that people strive for; a point that with conscious thought you have knowledge of a skill.  I think of it as having enough knowledge to be 'dangerous'.  You can function professionally as a programmer at this stage, but you lack a certain level of 'optimization'.&lt;/p&gt;

&lt;h4 id="unconsciouscompetence"&gt;Unconscious Competence&lt;/h4&gt;

&lt;p&gt;Unconscious competence is the final stage of mastery in a skill.  You can code without significant concentration and thought.  This is akin to 'autopilot' with coding.  It is more often achieved through practice and persistence than any one learning resource.  &lt;/p&gt;

&lt;p&gt;In software engineering mastery of individual skills may be possible, but as a whole it is a constant learning process.  That is why I love it.&lt;/p&gt;</content:encoded></item><item><title>Overcoming Imposter Syndrome</title><description>&lt;p&gt;I believe that what my single greatest hurdle in becoming a software engineer is accepting the idea that I can be successful at it.  I started learning to code earlier this year and it was imposing to say the least.  The diverse technologies available to learn combined with how in-depth&lt;/p&gt;</description><link>http://localhost:2368/overcoming-imposter-syndrome/</link><guid isPermaLink="false">fdca5319-cc04-4cbf-ae2a-ab34932f1497</guid><category>Hack Reactor</category><dc:creator>Todd Levin</dc:creator><pubDate>Thu, 01 Oct 2015 16:47:21 GMT</pubDate><content:encoded>&lt;p&gt;I believe that what my single greatest hurdle in becoming a software engineer is accepting the idea that I can be successful at it.  I started learning to code earlier this year and it was imposing to say the least.  The diverse technologies available to learn combined with how in-depth and complicated these programming languages appeared to be made starting difficult.&lt;/p&gt;

&lt;p&gt;So I did what most people do when they don’t know where to start, I asked random people on the internet.  I found the site &lt;a href="http://www.quora.com"&gt;Quora&lt;/a&gt; which was a wealth of information from people in the industry.  Impressive credentials, with complex, intelligent answers built up my feelings of inadequacy.&lt;/p&gt;

&lt;p&gt;I started learning JavaScript with the intention of interviewing with &lt;a href="http://www.hackreactor.com"&gt;Hack Reactor&lt;/a&gt;.  I set upon learning with a passion and improved my skills rapidly.  I began solving more and more complex problems and eventually got accepted by Hack Reactor despite how highly selective they are.  Throughout this process I thought I had no chance and wasn’t good enough.&lt;/p&gt;

&lt;p&gt;I found out there is a concept that is prevalent in software engineering called the ‘&lt;a href="https://en.wikipedia.org/wiki/Imposter_syndrome"&gt;Imposter Syndrome&lt;/a&gt;’ which is a belief, despite evidence to the contrary, that success is the result of luck, timing, or the work of others.  The idea that you are a fraud amongst ‘real’ software engineers.&lt;/p&gt;

&lt;p&gt;The work I have done on the prerequisite studies for Hack Reactor and my interactions with fellow classmates made me aware that the feeling of inadequacy was fairly common.  I continue to have success that I attribute to persistence and a stubborn desire to solve the problem.  One day I hope I can acknowledge that my success is the result of technical skill.&lt;/p&gt;</content:encoded></item></channel></rss>